# The video starts with open source control management(SCM)

/_as i already have an idea what is version control:a system that tracks and manages changes to software code. It keeps a record of every change, including the author, timestamp, and other details_/

--What is even a SCM or git?
->Source Control Management (SCM) is a system that manages and tracks changes to a codebase, enabling collaboration among multiple developers and providing a version history of the software.
...
Now that we know what is scm why was there a need of storage system like this?
->Loss of Code: Without versioning, accidental changes or deletions could lead to irreversible data loss.
Collaboration Issues: Difficulty in managing collaborative projects, leading to conflicting changes.
Code Confusion: Lack of a version history can result in confusion about the state of the codebase.
Quality Assurance Challenges: Hard to track changes and identify when and how bugs were introduced.
...
$ git config --global user.name "Gucci ki kameez"

What is this above? what does this evven mean? what does the components refere to?

git config: The command for configuring Git settings.
--global: Specifies that the configuration should apply globally to all repositories.
user.name: The specific Git configuration option for setting the user's name.
"Gucci Ki Kameez": The value being assigned to the user.name configuration.

Clarity in Attribution: Clearly attributes code changes to a specific user.
Professionalism: Adds a professional touch by including author information in commits.
Accountability: Enhances accountability by associating changes with identifiable contributors.
Consistency: Maintains a consistent user identity across various Git repositories.

# you also need to declare your default email like global user.email abcd@gmail.com

$ git config --global init.default branchÂ main

git config: The command for configuring Git settings.
--global: Specifies that the configuration should apply globally to all repositories.
init.defaultBranch: The specific Git configuration option for setting the default branch name.
main: The value being assigned to the init.defaultBranch configuration.

How does it even standardise thing?

Run the Command: Execute the provided command in the terminal.
Verify Configuration: Confirm the change by checking the global Git configuration.
Initialize New Repositories: New repositories will now default to the specified branch name.
Update Existing Repositories: For existing repositories, manually update the default branch name.

$ git add index.htm

Need for Doing This:
Staging Changes: Preparing specific files or changes for the next commit.
Selective Commit: Choosing which changes to include in the next commit.
Version Control: Updating the version control system with modified files.
Commit Preparation: Facilitating the process of committing changes.

git add: The command for staging changes in Git.
index.htm: The specific file (or files) being staged in this instance.

NOW THE NEXT QUESTION I SAW WAS .gitignore why even it is required.what does it even do?

->The .gitignore file is used to specify intentionally untracked files and directories that Git should ignore when managing a project.

.gitignore: The filename indicating Git should interpret the file for exclusion rules.
Line in File: Each line in the .gitignore file specifies a file or directory pattern to ignore.

i you wanna see that the specific fiile/set of files are ignored use this:
-> git status
if you want to add all file use :
-> git add --all/A/.

if ypu haven't committed the files are in a state of"STAGING"
i.e they are stuck .

$ git commit -m "first commit committing all files to the repository"

Initial Project Snapshot: Creating the first commit to capture the initial state of the project.
Logging Progress: Documenting progress by committing changes at significant milestones.
Versioning Code: Implementing version control for tracking changes to codebase.
Providing Commit Messages: Adding informative commit messages for clarity.

Why to Use It:
Record Changes: Captures changes made to files in the project.
Track Project History: Establishes a chronological history of project evolution.
Collaboration: Enables collaboration by providing a shared history.
Rollback Capability: Facilitates the ability to roll back to specific points in time.

git commit: The command for recording changes to the repository.
-m: The flag indicating that the commit message will be provided inline.
"first commit committing all files to the repository": The commit message explaining the nature of the commit.

OKAY SO THIS IS IMPORTANT LIKE IF YOU EVER MODIFY THE CHANGES IN THE FILES OF YOURS USE git status TO SEE IT IT'LL SHOW MODIFIED.

AGAIN TO SEE WHAT CHANGES YOU'VE MADE USE:git diff

$ git restore staged index.htm

Need for Doing This:
Unstage Changes: To unstage specific changes before committing.
Correction of Staging Mistake: Rectifying accidental staging of files.
Selective Staging: Reversing the staging of specific files while keeping other changes.
Review Changes Before Commit: Undoing the staging of a file for further review.

Need for Doing This:
Unstage Changes: To unstage specific changes before committing.
Correction of Staging Mistake: Rectifying accidental staging of files.
Selective Staging: Reversing the staging of specific files while keeping other changes.
Review Changes Before Commit: Undoing the staging of a file for further review.

IF YOU'VE DELETED A FILE SPECIFICALLY BY ACCIDENT THERE IS ALSO A WAY TO RESTORE IT (IT ONLY WORKS IF YOU'VE PASSED THE STAGED LIMIT BY ADDING ALL OF THE FILES/ SPECIFICALLY THAT FILE)

git restore "file name"

if you want to see what thing you've committed over time
use : git log
if you wanna see it detailed use --oneline

$ git rebase -i --root

Need for Doing This:
Rewriting Initial Commit: To modify or reorder the first commit in the repository.
Squashing Commits: Combine multiple commits into a single commit for clarity.
Splitting Commits: Divide a large initial commit into smaller, more focused commits.
Changing Commit Order: Rearrange the order of commits to improve the project's commit history.

Introduction of Git Rebase: Git rebase was introduced for rewriting commit history.
Interactive Rebase: The -i flag added the ability to interactively rebase.
Handling the Root Commit: The --root option extended rebase to include the initial commit.
Community Adoption: Developers began using interactive rebase for more granular control.

Other Options:
git commit --amend: Amend the last commit to make changes to the initial commit.
git reset: Reset the branch to an earlier commit, discarding subsequent changes.
git cherry-pick: Apply specific commits from one branch to another.
Creating a New Initial Commit: Create a new branch and initial commit, abandoning the old history.

git rebase: The command for rewriting commit history.
-i: The flag for interactive mode during rebase.
--root: The option indicating that the root commit should be included in the rebase.

What are branches ?

In Git, branches are a crucial concept that allows developers to work on different features, bug fixes, or improvements simultaneously without interfering with each other's code. A branch in Git is essentially a lightweight movable pointer to a commit. When you create a new branch, it points to the commit you are currently on, and any new commits are added to that branch.

how to create new branch name:
git branch newbranchname
or
git switch -c 'branchname'

you can see how many branches you have using : git branch

git switch branchname (will switch branches)

if youre done with the branch youu can delete it:
git branch -d branchname

THE BRANCHES ARE EFFECITVELY USED WHEN YOU'VE TO FIX BUGS/DO ANY KIND OF CHANGES IN THE FILES .

TO COMMIT ANY CHANGES TO A NEW BRANCH USE :
git commit -a -m"NEW CHANGE"

GITHUB:

git remote add origin https://github.com/yorgitid/reopname

git branch -M main

git push-u origin main

Why to Use It:
Remote Association: Establish a connection between the local repository and a remote GitHub repository.
Default Branch Name Change: Adopt an inclusive default branch naming convention (e.g., main instead of master).
Upstream Branch Set-up: Set up the upstream branch for easy tracking of changes.
Synchronization with GitHub: Ensure that local and remote repositories are synchronized.

How to Use It:
Remote Addition: Use git remote add origin <repository_url> to add a remote.
Branch Renaming: Use git branch -M main to rename the default branch to main.
Push with -u Flag: Use git push -u origin main to push changes and set the upstream branch.

What Each Word in the Line Means:
git remote add origin: Command to add a remote named "origin" with a specified repository URL.
https://github.com/kevstrat/KevinCookieCompany.com.git: The GitHub repository URL.
git branch -M main: Command to rename the current branch to main.
git push -u origin main: Command to push the local main branch to the remote repository and set it as the upstream branch.

AS WE GO DEEP INTO THE GITHUB SECTION WE GET TO KOW THE TABS OF THE GITHUB ESSENTIALS HERE THEY ARE:

### 1. **Code:**

- **Repositories:**
  - Hosts project files, including source code, documentation, and assets.
- **Commits:**
  - Snapshot of changes made to files in the repository.
- **Branches:**
  - Independent lines of development for features, bug fixes, etc.
- **Tags:**
  - Named pointers to specific commits for versioning.

### 2. **Issues:**

- **Issue Tracker:**
  - Tracks tasks, enhancements, bugs, and other kinds of questions.
- **Labels:**
  - Categorizes and organizes issues.
- **Milestones:**
  - Groups related issues to achieve a specific goal.
- **Assignees:**
  - Designates individuals responsible for addressing specific issues.

### 3. **Pull Requests:**

- **Branch Integration:**
  - Propose changes made in a branch to be merged into another.
- **Code Review:**
  - Facilitates collaborative code review by peers.
- **Status Checks:**
  - Automated checks to ensure proposed changes meet criteria.
- **Merge Options:**
  - Decide when and how to merge changes into the target branch.

### 4. **Actions:**

- **Workflow Automation:**
  - Define custom workflows for continuous integration and deployment.
- **Event Triggers:**
  - Execute actions in response to specific events, like pushes or pull requests.
- **Artifact Storage:**
  - Store and retrieve build artifacts or other outputs.

### 5. **Security:**

- **Code Scanning:**
  - Identifies vulnerabilities in the codebase.
- **Dependency Graph:**
  - Visualizes dependencies and their versions.
- **Secrets:**
  - Safely store and manage encrypted secrets.
- **Security Advisories:**
  - Displays security advisories for dependencies.

### 6. **Insights:**

- **Analytics:**
  - Provides statistics on code contributions, traffic, and more.
- **Contributors:**
  - Lists individuals contributing to the repository.
- **Community:**
  - Metrics on the community's engagement with the project.

### 7. **Projects:**

- **Task Boards:**
  - Organizes and prioritizes work using customizable boards.
- **Automated Workflows:**
  - Automatically moves cards between columns based on defined rules.
- **Collaboration:**
  - Enhances team collaboration and project management.

### 8. **Wiki:**

- **Documentation:**
  - Collaboratively edit and publish documentation for the repository.
- **Markdown Support:**
  - Write content using Markdown syntax.
- **Versioned Pages:**
  - View and compare different versions of wiki pages.

### 9. **Settings:**

- **Repository Settings:**
  - Configure repository-specific settings.
- **Collaborator Management:**
  - Control access and permissions for contributors.
- **Webhooks:**
  - Integrate with external services by configuring webhooks.

### 10. **Network:**

- **Forks:**
  - Create a copy of a repository to contribute without affecting the original.
- **Stars:**
  - Mark repositories as favorites for easy access.
- **Followers:**
  - Keep track of users whose activity you're interested in.

### 11. **Pull Requests:**

- **Branch Integration:**
  - Propose changes made in a branch to be merged into another.
- **Code Review:**
  - Facilitates collaborative code review by peers.
- **Status Checks:**
  - Automated checks to ensure proposed changes meet criteria.
- **Merge Options:**
  - Decide when and how to merge changes into the target branch.

### 12. **Releases:**

- **Version Tagging:**
  - Group together a set of features or bug fixes and create a release.
- **Changelog Generation:**
  - Automatically generate changelog entries based on commit history.
- **Asset Attachments:**
  - Attach binaries, installers, or other assets to a release.

### 13. **Environment:**

- **Deployment Environments:**
  - Define deployment environments for your application.
- **Status Checks:**
  - Monitor the status of deployments directly from GitHub.
  - **Rollback:**
  - Revert to a previous deployment state if needed.

### 14. **Marketplace:**

- **GitHub Apps:**
  - Install third-party apps to extend GitHub's functionality.
- **Actions and Workflows:**
  - Discover and share workflows and actions created by the community.
  - **Integrations:**
  - Explore integrations with other tools and services.

These are just some of the many features available on GitHub, each contributing to a robust collaborative development environment.
